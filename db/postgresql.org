#+TITLE: PostgreSQL

https://www.postgresql.org/docs/13/protocol-message-formats.html

* Add "simple query"

Here's the thing. Postgresql can take a string that has multiple statements as a
single query.

#+begin_quote
The response to a SELECT query (or other queries that return row sets, such as
EXPLAIN or SHOW) normally consists of RowDescription, zero or more DataRow
messages, and then CommandComplete. [...]

Since a query string could contain several queries (separated by semicolons),
there might be several such response sequences before the backend finishes
processing the query string. ReadyForQuery is issued when the entire string has
been processed and the backend is ready to accept a new query string.
#+end_quote

In the driver it is this.

#+begin_src scheme :noweb-ref postgresql-simple-query
(def (postgresql-simple-query! conn str)
  (with-driver conn driver
    (!!postgresql.simple-query driver str)))
#+end_src

** Getting Started
*** Connect to a server

Let's connect to a local server.

#+begin_src scheme
(import :drewc/db/postgresql-driver :drewc/db/postgresql-driver
        :drewc/db/dbi)

(def conn (postgresql-connect! "localhost" 5432 "test" "test" #f))
#+end_src

We need to access the socket directly to hack away without a constant recompilation.

#+begin_src scheme
(def sock (postgresql-socket conn))
#+end_src

*** Send the ~Query~ message

We send messages using [[#postgresqlSend][~postgresql-send!~]].

#+begin_src scheme
(extern namespace: "drewc/db/postgresql-driver" postgresql-send!)
(def (send! msg) (postgresql-send! sock msg))
#+end_src

https://www.postgresql.org/docs/13/protocol-flow.html#id-1.10.5.7.4

- Query (F) :: The (F) means it a [[#frontEndMessages][Front End Message]]
  - Byte1('Q') :: Identifies the message as a simple query.
  - Int32 :: Length of message contents in bytes, including self.
  - String :: The query string itself.

The ~postgresql-send!~ procedure takes care of the byte and length for us.

The *Front End Message* takes care of the marshaling.

#+begin_src scheme
  (Query                    #\Q  marshal-query)
#+end_src

So that means that all we need is to send the query.

#+begin_src scheme
(send! ['Query "SELECT 42 \"is the answer\",
                ' to life, the universe, ' \"and everything\""])
#+end_src

**** ~marshal-query~

#+begin_src scheme
(def (marshal-query body)
  (with ([sql] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string sql bio)
      bio)))
#+end_src

*** Receive the Response

According to the docs a select will first return a ~RowDescription~.

#+begin_src scheme
(extern namespace: "drewc/db/postgresql-driver" postgresql-recv!)
(import :std/logger)

(def buffer (box (make-u8vector 1024)))

(def (recv!)
    (match (postgresql-recv! sock buffer)
      (['NoticeResponse msg . irritants]
       (notice! msg irritants)
       (recv!))
      (msg msg)))

  (def (notice! msg irritants)
    (warnf "NOTICE: ~a ~a" msg irritants))
#+end_src

Lets see!

#+begin_src scheme
(def stmt-data (list (recv!) (recv!)))

;;> stmt-data
;;=>
;; ((RowDescription ("is the answer" 0 0 23 4 -1 0)
;;                  ("and everything" 0 0 25 -1 -1 0))
;;  (DataRow "42" " to life, the universe, "))
#+end_src

Now if luck would have it we get CommandComplete and ReadyForQuery.

#+begin_src scheme
(list (recv!) (recv!))
  =>
 ((CommandComplete "SELECT 1") (RowDescription ("?column?" 0 0 23 4 -1 0)))
#+end_src

That's awesomesauce! We'll use that to create a simple query.


** Start Simple Query in the Driver

There are some local "globals" in the driver that map the driver's path.

#+begin_src scheme
(import :std/actor/proto
        :std/actor/message
        :std/misc/channel
        :std/misc/list)
(def query-limit 1000)
(def query-output #f)
(def query-token #f)
(def simple-query #f)
#+end_src

*** Sync, maybe, and ~resync!~

The local global use! Essentially, if we are within a query either want to
ignore the rest or are simply done we can wait for a ~ReadyForQuery~ response.

#+begin_src scheme
(def (resync!)
    (let lp ()
      (match (recv!)
        (['ReadyForQuery _]
         (void))
        (else
         (lp)))))

(def (maybe-sync!)
  (when query-output
    (channel-sync query-output (make-sql-error "portal expired" [] 'postgresql-query-pump!))
    (channel-close query-output)
    (set! query-output #f)
    (set! query-token #f)
    (set! simple-query #f)
    (resync!)
    (let (to-close deferred-close)
      (set! deferred-close [])
      (for-each close to-close))))
#+end_src

*** Simple Query Start

To start with with ~send!~ the query, make a unique token, and mention this is a simple query (possibly?).

#+begin_src scheme :noweb-ref simple-query-start
(def (simple-query-start str)
    (maybe-sync!)
    (send! ['Query str])
    (let ((ch (make-channel query-limit))
             (token (make-!token)))
         (set! query-output ch)
         (set! query-token token)
         (set! simple-query #t)
         (values ch token)))
#+end_src

** Simple Query Pump: pass along the results

#+begin_quote
A simple query cycle is initiated by the frontend sending a Query message to the backend. The message includes an SQL command (or commands) expressed as a text string.

The possible response messages from the backend are:

CommandComplete
An SQL command completed normally.

CopyInResponse
The backend is ready to copy data from the frontend to a table; see Section 53.2.5.

CopyOutResponse
The backend is ready to copy data from a table to the frontend; see Section 53.2.5.

RowDescription
Indicates that rows are about to be returned in response to a SELECT, FETCH, etc query. The contents of this message describe the column layout of the rows. This will be followed by a DataRow message for each row being returned to the frontend.

DataRow
One of the set of rows returned by a SELECT, FETCH, etc query.

EmptyQueryResponse
An empty query string was recognized.

ErrorResponse
An error has occurred.

ReadyForQuery
Processing of the query string is complete. A separate message is sent to indicate this because the query string might contain multiple SQL commands. (CommandComplete marks the end of processing one SQL command, not the whole string.) ReadyForQuery will always be sent, whether processing terminates successfully or with an error.

NoticeResponse
A warning message has been issued in relation to the query. Notices are in addition to other responses, i.e., the backend will continue processing the command.

-- https://www.postgresql.org/docs/current/protocol-flow.html#id-1.10.5.7.4


#+end_quote

OK! So a query and then the result is returned until ~ReadyForQuery~.

We do not really care about the results beyond passing them up to those that do.

#+begin_src scheme :noweb-ref postgresql-message
(defstruct postgresql-message (name args)
  print: (args))
(defstruct (postgresql-RowDescription postgresql-message) ()
  constructor: :init!
  final: #t)
(defmethod {:init! postgresql-RowDescription}
  (lambda (self desc)
    (struct-instance-init! self 'RowDescription desc)))
(defstruct (postgresql-CommandComplete postgresql-message) ()
  constructor: :init!
  final: #t)
(defmethod {:init! postgresql-CommandComplete}
  (lambda (self desc)
    (struct-instance-init! self 'CommandComplete desc)))
#+end_src

*** ~simple-query-pump~
The only thing that makes this "special" is the ~query-limit~. When we reach the
limit the pump stops running until signaled to run again.

This is essentially so we can iterate over a tonne a rows without needing them
all in memory.

Because ~#!eof~ is a value that maybe abused somewhat, the end of a statement that outputs rows is marked by ~#!void~.

We do this by setting "inside rows" to the token when a RowDescription comes.

If the inside-rows is also the query-token we are currently inside a "statement".

#+begin_src scheme :noweb-ref simple-query-pump
(def inside-rows #f)
(def (simple-query-pump)
  (let/cc break
      (let lp ()
        (let ((r (recv!)))
          (match r
            (['RowDescription . fields]
             (channel-sync query-output (postgresql-RowDescription fields))
             (set! inside-rows query-token)
             (lp))
            (['CommandComplete tag]
             (when (eq? inside-rows query-token)
               (channel-sync query-output (void))
               (set! inside-rows #f))
             (channel-sync query-output (postgresql-CommandComplete tag))
             (lp))
            (['DataRow . cols]
             (cond                                        ;
              ((channel-try-put query-output cols)        ;
               (lp))                                      ;
              (else                                       ;
               (channel-sync query-output cols query-token) ;
               (break))))
            (['ReadyForQuery _]
             (channel-sync query-output (eof-object)))
            (['EmptyQueryResponse]
             (lp))
            (['ErrorResponse msg . irritants]
             (channel-sync query-output (make-sql-error msg irritants 'postgresql-simple-query!))
             (lp))))))
    (channel-close query-output)
    (set! query-output #f)
    (set! query-token #f)
    (set! simple-query #f)
    (set! inside-rows #f))
#+end_src

*** Test out the pump

Start a query with 3 different commands.

#+begin_src scheme
(defvalues (inp token)
            (simple-query-start "
BEGIN;
CREATE TEMP TABLE test_tbl
  AS SELECT tablename FROM pg_tables WHERE schemaname = 'pg_catalog';
SELECT count(*) FROM test_tbl ;
SELECT * from test_tbl LIMIT 2;
ABORT;"))

(def msgs (begin (simple-query-pump) (for/collect (msg (:iter inp)) msg)))

#+end_src

We can see what we output.

#+begin_src scheme
(user)> (pretty-print msgs)
(#<postgresql-CommandComplete #126 args: "BEGIN">
 #<postgresql-CommandComplete #127 args: "SELECT 62">
 #<postgresql-RowDescription #128 args: (("count" 0 0 20 8 -1 0))>
 ("62")
 #<postgresql-CommandComplete #129 args: "SELECT 1">
 #<postgresql-RowDescription #130 args: (("tablename" 58396 1 19 64 -1 0))>
 ("pg_statistic")
 ("pg_type")
 #<postgresql-CommandComplete #131 args: "SELECT 2">
 #<postgresql-CommandComplete #132 args: "ROLLBACK">)
#!void
#+end_src

That's awesome! It's enough for the fronted to see what objects to create.

But, what about the limit?

Let's make it shorter lol.

#+begin_src scheme
(set! query-limit 1)
(defvalues (inp token)
            (simple-query-start "
BEGIN;
CREATE TEMP TABLE test_tbl
  AS SELECT tablename FROM pg_tables WHERE schemaname = 'pg_catalog';
SELECT * from test_tbl LIMIT 5;
ABORT;"))

(def msgs
  (begin (simple-query-pump)
         (let ((msgs []))
  (let again () (def m (channel-try-get inp))
    (cond (m (set! msgs [m msgs ...]) (again))
          (else (reverse msgs)))))))
#+end_src

What does that give us?

#+begin_src scheme
(user)> (pretty-print msgs)
(#<postgresql-CommandComplete #38 args: "BEGIN">
 #<postgresql-CommandComplete #39 args: "SELECT 62">
 #<postgresql-RowDescription #40 args: (("tablename" 58464 1 19 64 -1 0))>
 ("pg_statistic")
 #<!token #41>)
#!void
#+end_src

That ~!token~ means we need to continue as we've reached the limit.

So to continue we need to start pumping again.

The first way is to write a driver function, [[#postgresqlDriverContinue][continue]], which can be integrated
with the driver.

#+begin_src scheme
(set! msgs
  (begin (continue token)
         (let ((msgs []))
  (let again () (def m (channel-try-get inp))
    (cond ((and m (not (eof-object? m))) (set! msgs [m msgs ...]) (again))
          (else (reverse msgs)))))))
  (pretty-print msgs)

 ;; => (("pg_type") ("pg_foreign_table") #<!token #59>)
#+end_src

Twice more?
#+begin_src scheme
(set! msgs
  (begin (postgresql-continue! conn token)
         (postgresql-continue! conn token)
         (let ((msgs []))
  (let again () (def m (channel-try-get inp))
    (cond ((and m (not (eof-object? m))) (set! msgs [m msgs ...]) (again))
          (else (reverse msgs)))))))

 ;; => (#<postgresql-CommandComplete #64 args: "SELECT 5">
 ;;     #<postgresql-CommandComplete #65 args: "ROLLBACK">)
#+end_src

And we can see that the channel is done and closed, as is the query.

#+begin_src scheme
(user)> (list (channel-try-get inp) query-token query-output simple-query)
(#!eof #f #f #f)
#+end_src


** The Front End

We need a connection to our db.

#+begin_src scheme
  (def conn (postgresql-connect host: "localhost" port: 5432
                                user: "test" passwd: "test"))
#+end_src

Now just like the backend we get some input that needs processing.

#+begin_src scheme
(defvalues (inp token)
        (postgresql-simple-query! conn "BEGIN;
  CREATE TEMP TABLE foo (bar int);
  INSERT INTO foo VALUES (42) RETURNING 'the answer:', bar;
  ROLLBACK;"))
#+end_src

That gives us a little of what we need. I

#+begin_src scheme
(user)> (pretty-print (for/collect (msg (:iter inp)) msg))
(#<postgresql-CommandComplete #43 args: "BEGIN">
 #<postgresql-CommandComplete #44 args: "CREATE TABLE">
 #<postgresql-RowDescription #45
    args: (("?column?" 0 0 25 -1 -1 0) ("bar" 58527 1 23 4 -1 0))>
 ("the answer:" "42")
 #<postgresql-CommandComplete #46 args: "INSERT 0 1">
 #<postgresql-CommandComplete #47 args: "ROLLBACK">)
#!void
#+end_src

That tells me that "Commands" are the classification I was looking for.

So everything is a [[#frontEndCommand][Command]], with a query command containing and returning other commands.

** Query command -> commands

We'll try a query with 4 commands.

#+begin_src scheme
(begin
  (import :drewc/db/postgresql :drewc/db/dbi :std/iter)
  (extern pretty-print)


  (def conn (postgresql-connect host:  "localhost" port: 5432 user: "maxclaims" passwd: "y3am2e!!"))

  (def q (postgresql-query conn "BEGIN;
  CREATE TEMP TABLE foo (bar int);
  INSERT INTO foo VALUES (42), (420) RETURNING 'the answer to' \"what is\", bar ltuae ;
  ROLLBACK;"))

  (pretty-print (for/collect (cmd (:iter q)) (pretty-print cmd)
    (let (o (sql-query cmd))
      (cons (postgresql-command-complete cmd)
            (map (cut map cons {columns cmd} <>) (map vector->list o)))))))
#+end_src

* Prepared Statements

Statements can be prepared ahead of time.

#+begin_src scheme

#+end_src

* Front End

** Connection
:PROPERTIES:
:CUSTOM_ID: frontEndConnection
:END:

We need to connect to a server. Time to sub [[file:dbi.org::#connectionStruct][Connection]].

#+begin_src scheme :noweb-ref postgresql-connection
(defstruct (postgresql-connection connection) () final: #t)

(def (postgresql-connect host: (host "127.0.0.1")
                         port: (port 5432)
                         user: user
                         passwd: passwd
                         db: (db #f))
  (let (driver (postgresql-connect! host port user passwd db))
    (make-postgresql-connection driver)))

(defmethod {close postgresql-connection}
  (lambda (self)
    (postgresql-close! self)))
#+end_src

*** Prepare a Statement
:PROPERTIES:
:CUSTOM_ID: frontEndConnectionPrepare
:END:

We use a connection to make and create a [[#frontEndStatements][Statement]].

The driver takes care of what we need so in reality all we do is provide a name and the sql.

#+begin_src scheme :noweb-ref Prepared Statement Methods
(defmethod {prepare postgresql-connection}
  (lambda (self sql)
    (let* ((name (symbol->string (gensym 'stmt)))
           ((values params cols)
            (postgresql-prepare-statement! self name sql)))
      (make-postgresql-statement self name: name cols params: params))))
#+end_src
** Command
:PROPERTIES:
:CUSTOM_ID: frontEndCommand
:END:

A command is the encapsulation of the front end's interaction with the server.

All commands are DBI [[file:dbi.org::#statementStruct][Statements]]. For the most part they are unnamed. But they do need a name of somesort to say they are running.

#+begin_src scheme :noweb-ref command struct
(defstruct (postgresql-command statement) (conn complete input token)
  constructor: :init!
  print: (complete))

(defstruct !unnamed () final: t)
(def unnamed-command (make-!unnamed))

(defmethod {:init! postgresql-command}
  (lambda (self conn name: (name unnamed-command) complete: (complete #f))
    (struct-instance-init! self name conn complete)))


(defmethod {query-start postgresql-command} void)
(defmethod {query-fini postgresql-command} postgresql-command::reset)
(defmethod {query-fetch postgresql-command} (lambda _ iter-end))
(defmethod {query-row postgresql-command} postgresql-command-complete)
(defmethod {columns postgresql-command} (lambda _ '()))
#+end_src

*** Reset

For some commands the db and driver are returning things even though we are done with them. Even if they are not, we want to be done with it.

The driver knows if we are still in this command, so we just say to reset it.

#+begin_src scheme :noweb-ref command reset
(defmethod {reset postgresql-command}
  (lambda (self)
    (alet (token (postgresql-command-token self))
      (postgresql-reset! (postgresql-command-conn self) token)
      (set! (postgresql-command-token self) #f)
      (set! (postgresql-command-input self) #f))))
#+end_src
** Statement
:PROPERTIES:
:CUSTOM_ID: frontEndStatements
:END:

#+begin_src scheme :noweb-ref statement struct
(defstruct (postgresql-statement postgresql-command) (cols params bind row)
  constructor: :init!
  final: #t)

(defmethod {:init! postgresql-statement}
  (lambda (self conn name: (name unnamed-command)
                cols params: (params []))
    (struct-instance-init! self name conn #f #f #f cols params)))
#+end_src


A row is easy.

#+begin_src scheme :noweb-ref statement query
(defmethod {query-row postgresql-statement}
  (lambda (self)
    (postgresql-statement-row self)))
#+end_src

As are columns.

#+begin_src scheme :noweb-ref statement query
(defmethod {columns postgresql-statement}
   (lambda (self)
     (map car (postgresql-statement-cols self))))


#+end_src

And to ~-fini~'sh it up we just reset it

#+begin_src scheme :noweb-ref statement query

(defmethod {query-fini postgresql-statement}
   postgresql-statement::reset)
#+end_src

** Prepared statements

Some statements are prepared and can be used as individual procedures.

They are prepared via a [[#frontEndConnectionPrepare][Connection]].

*** Binding

For binding a statement we simply serialize the args of the statement. That way we have something to call the prepared statement with.

#+begin_src scheme :noweb-ref Prepared Statement Methods
(defmethod {bind postgresql-statement}
  (lambda (self . args)
    (def (value->binding type-oid arg)
      (cond
       ((not arg)
        ;; #f is NULL normally ... unless it's a BOOL
        (if (fx= type-oid 16)
          (serialize-boolean arg)
          #f))
       ((string? arg) arg)
       ((catalog-serializer (current-catalog) type-oid)
        => (cut <> arg))
       (else
        (error "Cannot bind; Parameter type oid not in (current-catalog)" type-oid arg))))
    (let* ((params (postgresql-statement-params self))
           (bind (map value->binding params args)))
      (set! (postgresql-statement-bind self) bind)
      (void))))
#+end_src

**** Clear binding

#+begin_src scheme :noweb-ref Prepared Statement Methods
(defmethod {clear postgresql-statement}
  (lambda (self)
    (set! (postgresql-statement-bind self) #f)))
#+end_src

*** Exec

There are some times when we just want to execute a statement and do not care about rows.

The driver returns the value of CommandComplete, so all we really need to do is
set that and return it.

#+begin_src scheme :noweb-ref Prepared Statement Methods
(defmethod {exec postgresql-statement}
  (lambda (self)
    (with ((postgresql-statement name conn _ _ _ _ _ bind) self)
      (let (comp (postgresql-exec! conn name (or bind [])))
        (begin0 comp
          (set! (postgresql-command-complete self) comp))))))
#+end_src

*** Finalize: Close the prepared statement and reset

#+begin_src scheme :noweb-ref Prepared Statement Methods
(defmethod {finalize postgresql-statement}
  (lambda (self)
    (with ((postgresql-statement name conn) self)
      (postgresql-statement::reset self)
      (postgresql-close-statement! conn name))))
#+end_src

** Reset statement

#+begin_src scheme :noweb-ref Prepared Statement Methods
(defmethod {reset postgresql-statement}
  (lambda (self)
    (postgresql-command::reset self)
    (set! (postgresql-statement-row self) #f)))
#+end_src

** Statement Query

There are a few different types of statements. When one is fetched from a [[#frontEndQuery][Query]] it has already been started and is ~!unnamed?~.

#+begin_src scheme :noweb-ref statement query
(def (postgresql-statement-in-query? stmt)
  (!unnamed? (statement-e stmt)))

(defmethod {query-start postgresql-statement}
  (lambda (self)
    (unless (postgresql-statement-in-query? self)
    (with ((postgresql-statement name conn _ _ _ _ _ bind) self)
      (let ((values inp token) (postgresql-query! conn name (or bind [])))
        (set! (postgresql-command-token self) token)
        (set! (postgresql-command-input self) inp)
        (set! (postgresql-statement-row self) #f))))))

#+end_src


#+begin_src scheme :noweb-ref statement query
(defmethod {query-fetch postgresql-statement}
  (lambda (self)
    (def (result->row cols)
      (let (res (map result->value cols (postgresql-statement-cols self)))
        (cond
         ((null? res) #f)
         ((null? (cdr res))
          (car res))
         (else
          (list->vector res)))))

    (def (result->value res col)
      (and res ; NULL is #f
           (let (type-oid (list-ref col 3))
             (value-e res type-oid))))

    (def (value-e res type-oid)
      (cond
       ((catalog-deserializer (current-catalog) type-oid)
        => (cut <> res))
       (else res)))

    (cond
     ((postgresql-command-input self)
      => (lambda (inp)
           (let again ()
             (let (next (channel-get inp))
               (cond
                ((or (eof-object? next) (void? next))
                 (when (void? next)
                   (let ((next (channel-get inp)))
                     (set! (postgresql-command-complete self)
                       (postgresql-message-args next))))
                 (set! (postgresql-command-token self) #f)
                 (set! (postgresql-command-input self) #f)
                 (set! (postgresql-statement-row self) #f)
                 iter-end)
                ((exception? next)
                 (raise next))
                ((query-token? next)
                 (postgresql-continue! (postgresql-command-conn self) next)
                 (again))
                (else
                 (let (row (result->row next))
                   (set! (postgresql-statement-row self) row)
                   (void))))))))
     (else iter-end))))
#+end_src


** Query
:PROPERTIES:
:CUSTOM_ID: frontEndQuery
:END:

#+begin_src scheme :noweb-ref query struct
(defstruct (postgresql-query postgresql-command) (str cmd)
  constructor: :init!
  print: (str)
  final: #t)

(defmethod {:init! postgresql-query}
  (lambda (self conn str)
    (struct-instance-init! self unnamed-command conn #f #f #f str)))
#+end_src

The [[file:dbi.org::#statementIter][Iterate]] procedure needs 4 methods.

  - query-start
  - query-fetch
  - query-row
  - query-fini

A row is just the last command fetched.

#+begin_src scheme :noweb-ref query query
(defmethod {query-row postgresql-query} postgresql-query-cmd)
#+end_src

To start is very simple.

#+begin_src scheme :noweb-ref query query
(defmethod {query-start postgresql-query}
  (lambda (self)
    (with ((postgresql-query _ conn _ _ _ str) self)
      (let ((values inp token) (postgresql-simple-query! conn str))
        (set! (postgresql-command-token self) token)
        (set! (postgresql-command-input self) inp)))))
#+end_src

Fetching is slightly more complex. There are, ideally, only two objects that are looked at to return a single command from each fetch.

  - CommandComplete :: When there are no rows left or no rows at all this is
    what is given to us.
  - RowDescription :: When there are rows we get this.



#+begin_src scheme :noweb-ref query query
(defmethod {query-fetch postgresql-query}
  (lambda (self)
    (with ((postgresql-query _ conn _ inp token _ cmd) self)
      (if (not inp) iter-end
          (let again ()
             (let (next (channel-get inp))
               (cond
                ((eof-object? next)
                 (set! (postgresql-command-token self) #f)
                 (set! (postgresql-command-input self) #f)
                 iter-end)
                ((exception? next)
                 (raise next))
                ((query-token? next)
                 (postgresql-continue! (postgresql-command-conn self) next)
                 (again))
                ((postgresql-CommandComplete? next)
                 (let ((comp (postgresql-message-args next)))
                   (when cmd (set! (postgresql-command-input cmd) #f))
                   (cond ((or (not cmd) (postgresql-command-complete cmd))
                          (set! (postgresql-query-cmd self)
                            (make-postgresql-command conn complete: comp)))
                         (else
                          (set! (postgresql-command-complete cmd) comp)
                          (again))))
                 (void))
                ((postgresql-RowDescription? next)
                 (let (stmt (make-postgresql-statement
                             conn (postgresql-message-args next)))
                   (set! (postgresql-command-input stmt) inp)
                   ;; (set! (postgresql-command-token stmt) self)
                   (set! (postgresql-query-cmd self) stmt))
                 (void))
                (else
                 (again)))))))))
#+end_src







** Catalog

#+begin_src scheme :noweb-ref catalog
;;; catalog/pg_type.h
(defstruct catalog (s d)
  constructor: :init!
  final: #t)

(defmethod {:init! catalog}
  (lambda (self . mixin)
    (let ((s (make-hash-table-eq))
          (d (make-hash-table-eq)))
      (for-each
        (lambda (mixin)
          (hash-merge! s (catalog-s mixin))
          (hash-merge! d (catalog-d mixin)))
        mixin)
      (struct-instance-init! self s d))))

(def (catalog-serializer c oid)
  (hash-get (catalog-s c) oid))

(def (catalog-deserializer c oid)
  (hash-get (catalog-d c) oid))

(defrules defcatalog ()
  ((_ (name mixin ...) (oids serialize deserialize) ...)
   (begin
     (def name (make-catalog mixin ...))
     (defcatalog-type name oids serialize deserialize) ...))
  ((recur name . body)
   (identifier? #'name)
   (recur (name) . body)))

(defrules defcatalog-type ()
  ((_ name (oid ...) serialize deserialize)
   (begin
     (hash-put! (catalog-s name) oid serialize) ...
     (hash-put! (catalog-d name) oid deserialize) ...)))

(defrules defcatalog-default ()
  ((_ clause ...)
   (begin
     (defcatalog-type default-catalog . clause)
     ...)))

(def (serialize-boolean arg)
  (if arg "t" "f"))

(def (deserialize-boolean str)
  (if (member str '("t" "true" "TRUE" "y" "yes" "on" "1")) #t #f))

(def (serialize-date date)
  (date->string date "~Y-~m-~d"))

(def (deserialize-date str)
  (string->date str "~Y-~m-~d"))

(def (serialize-timestamp date)
  (date->string date "~Y-~m-~d ~H:~M:~S"))

(def (deserialize-timestamp str)
  (string->date str "~Y-~m-~d ~H:~M:~S"))

(def (serialize-timestamptz date)
  (date->string date "~Y-~m-~d ~H:~M:~S~z"))

(def (deserialize-timestamptz str)
  (string->date str "~Y-~m-~d ~H:~M:~S~z"))

(def (identity-string obj)
  (if (string? obj) obj
      (error "Bad argument; expected string" obj)))

(defcatalog default-catalog
  ;; BOOLOID
  ((16) serialize-boolean deserialize-boolean)
  ;; INT8OID INT2OID INT4OID FLOAT4OID FLOAT8OID NUMERICOID
  ((20 21 23 700 701 1700) number->string string->number)
  ;; CHAROID TEXTOID BPCHAROID VARCHAROID
  ((18 25 1042 1043) identity-string identity)
  ;; DATEOID
  ((1082) serialize-date deserialize-date)
  ;; TIMESTAMPOID
  ((1114) serialize-timestamp deserialize-timestamp)
  ;; TIMESTAMPTZOID
  ((1184) serialize-timestamptz deserialize-timestamptz)

  ;; Add more from the catalog here depending on actual needs...
  ;; - automagic json serialization/deserialization?
  ;;   add JSONOID with json-object->string string->json-object
  ;; - automagic uuid conversion?
  ;;   add UUIDOID with uuid->string string->uuid
  )

(def current-catalog
  (make-parameter default-catalog))
#+end_src
* The Backend Driver

#+begin_quote
PostgreSQL uses a message-based protocol for communication between frontends and
backends (clients and servers). The protocol is supported over TCP/IP and also
over Unix-domain sockets. Port number 5432 has been registered with IANA as the
customary TCP port number for servers supporting this protocol, but in practice
any non-privileged port number can be used.
#+end_quote

That's the sense of it. We have a function that runs in a thread and implements
the communication protocol. We interact with that protocol and bob's your uncle.

** ~postgresql-socket~: Sometimes we need to hack!

Whiles most of the interaction with the PostgreSQL server is automated and
buried there are times when we want to interact with the socket outside of our driver.

So once we've [[#postgresqlConnect][~-connect!~]]ed we can see the socket.

#+begin_src scheme :noweb-ref postgresql-socket
(def postgresql-socket thread-specific)
#+end_src


** ~postgresql-connect!~: The startup
:PROPERTIES:
:CUSTOM_ID: postgresqlConnect
:END:

Connecting to the server and then spawning and returning the driver thread.

#+begin_src scheme :noweb-ref postgresql-connect!
(def (postgresql-connect! host port user passwd db)
  (def sock
    (open-tcp-client [server-address: host port-number: port]))

  (def buffer
    (box (make-u8vector 1024)))

  (def (start-driver! sock)
    (DEBUG "STARTING DRIVER")
    (let lp ()
      (match (postgresql-recv! sock buffer)
        (['ReadyForQuery _]
         (let ((t (spawn/name 'postgresql-connection postgresql-driver sock)))
           (set! (thread-specific t) sock)
           t))
        (['ErrorResponse msg . irritants]
         (apply raise-io-error 'postgresql-connect! msg irritants))
        (['NoticeResponse msg . irritants]
         (warnf "NOTICE: ~a ~a" msg irritants)
         (lp))
        (else
         (lp)))))

  (defrules send! ()
    ((_ msg)
     (postgresql-send! sock msg)))

  (defrules recv! ()
    ((_ clause ...)
     (match (postgresql-recv! sock buffer)
       clause ...
       (['ErrorResponse msg . irritants]
        (apply raise-io-error 'postgresql-connect! msg irritants))
       (unexpected
        (raise-io-error 'postgresql-connect! "unexpected message" unexpected)))))

  (def (authen-pass sock pass)
    (send! ['PasswordMessage pass])
    (recv!
     (['AuthenticationRequest 'AuthenticationOk]
      (start-driver! sock))))

  (def (authen-cleartext sock)
    (DEBUG "AUTHEN CLEARTEXT")
    (authen-pass sock passwd))

  (def (authen-md5 sock salt)
    (def (md5-hex data)
      (hex-encode (md5 data)))

    (DEBUG "AUTHEN MD5")
    (let* ((word1 (string-append passwd user))
           (word2 (md5-hex word1))
           (word3 (u8vector-append (string->utf8 word2) salt))
           (word4 (md5-hex word3))
           (pass (string-append "md5" word4)))
      (authen-pass sock pass)))

  (def (authen-sasl sock mechanisms)
    (DEBUG "AUTHEN SASL")
    (unless (member "SCRAM-SHA-256" mechanisms)
      (raise-io-error 'postgresql-connect! "unknown SASL authentication mechanisms" mechanisms))
    (let* ((ctx (scram-sha-256-begin "" passwd))
           (msg (scram-client-first-message ctx)))
      (send! ['SASLInitialResponse "SCRAM-SHA-256" msg])
      (recv!
       (['AuthenticationRequest 'AuthenticationSASLContinue msg]
        (scram-client-first-server-message! ctx msg)
        (let (msg (scram-client-final-message ctx))
          (send! ['SASLResponse msg])
          (recv!
           (['AuthenticationRequest 'AuthenticationSASLFinal msg]
            (scram-client-final-server-message! ctx msg)
            (recv!
             (['AuthenticationRequest 'AuthenticationOk]
              (start-driver! sock))))))))))

  (start-logger!)
  (DEBUG "STARTUP")
  (try
   (send! ['StartupMessage ["user" . user] (if db [["database" . db]] []) ...])
   (recv!
    (['AuthenticationRequest what . rest]
     (DEBUG "AUTHENTICATION REQUEST " what)
     (case what
       ((AuthenticationOk)
        (start-driver! sock))
       ((AuthenticationCleartextPassword)
        (authen-cleartext sock))
       ((AuthenticationMD5Password)
        (authen-md5 sock (car rest)))
       ((AuthenticationSASL)
        (authen-sasl sock rest))
       (else
        (raise-io-error 'postgresql-connect! "unsupported authentication mechanism" what)))))
   (catch (e)
     (close-port sock)
     (raise e))))
#+end_src


** ~postgresql-driver~: The thread that drives our interaction

There's a thread that talks to the server.

*** Continue
:PROPERTIES:
:CUSTOM_ID: postgresqlDriverContinue
:END:

We may need to continue with one of our pumps.

#+begin_src scheme :noweb-ref continue
(def (continue token)
  (when (eq? token query-token)
    (if simple-query
      (simple-query-pump)
      (query-pump))))
#+end_src


*** /Proc/ ~postgresql-driver~

#+begin_src scheme :noweb-ref postgresql-driver :noweb yes
(def (postgresql-driver sock)
  (def query-limit 1000)
  (def query-output #f)
  (def query-token #f)
  (def simple-query #f)

  (def buffer (box (make-u8vector 1024)))

  (def deferred-close [])

  (def (send! msg)
    (postgresql-send! sock msg))

  (def (recv!)
    (match (postgresql-recv! sock buffer)
      (['NoticeResponse msg . irritants]
       (notice! msg irritants)
       (recv!))
      (msg msg)))

  (def (notice! msg irritants)
    (warnf "NOTICE: ~a ~a" msg irritants))

  (def (resync!)
    (let lp ()
      (match (recv!)
        (['ReadyForQuery _]
         (void))
        (else
         (lp)))))

  (def (maybe-sync!)
    (when query-output
      (channel-sync query-output (make-sql-error "portal expired" [] 'postgresql-query-pump!))
      (channel-close query-output)
      (set! query-output #f)
      (set! query-token #f)
      (resync!)
      (let (to-close deferred-close)
        (set! deferred-close [])
        (for-each close to-close))))

  (def (prepare name sql)
    ;; Parse (name sql) -> ParseComplete | ErrorResponse
    ;; Describe (name)  -> ParameterDescription | ErrorResponse
    ;;                     RowDescription | NoData
    ;; Sync             -> ReadyForQuery
    (def params #f)
    (def cols #f)

    (maybe-sync!)
    (send! ['Parse name sql])
    (send! ['Describe #\S name])
    (send! '(Sync))
    (match (recv!)
      (['ParseComplete]
       (void))
      (['ErrorResponse msg . irritants]
       (resync!)
       (apply raise-sql-error 'postgresql-prepare! msg irritants)))
    (match (recv!)
      (['ParameterDescription . query-params]
       (set! params query-params))
      (['ErrorResponse msg . irritants]
       (resync!)
       (apply raise-sql-error 'postgresql-prepare! msg irritants)))
    (match (recv!)
      (['RowDescription . fields]
       (set! cols fields))
      (['NoData]
       (set! cols [])))
    (resync!)
    (values params cols))

  (def (exec name params)
    ;; Bind ("" name params) ->  BindComplete | ErrorResponse
    ;; Execute ("")          -> DataRow ...
    ;;                          CommandComplete | EmptyQueryResponse
    ;;                          | ErrorResponse | PortalSuspended.
    ;; Sync                  -> ReadyForQuery
    (def res #f)

    (maybe-sync!)
    (send! ['Bind "" name . params])
    (send! '(Execute "" 1))
    (send! '(Sync))
    (match (recv!)
      (['BindComplete]
       (void))
      (['ErrorResponse msg . irritants]
       (resync!)
       (apply raise-sql-error 'postgresql-exec! msg irritants)))
    (let lp ()
      (match (recv!)
        (['DataRow . cols]
         (lp))
        (['CommandComplete tag]
         (set! res tag))
        ([(or 'PortalSuspended 'EmptyQueryResponse)]
         (void))
        (['ErrorResponse msg . irritants]
         (resync!)
         (apply raise-sql-error 'postgreql-exec msg irritants))))
    (resync!)
    res)

  ;; Query backpressure mechanism: the query pump reads and buffers up
  ;; to query-limit rows before requiring a continue signal from
  ;; the query client.
  ;; If the client aborts (or issues a new query), the remaining results
  ;; of the query will be skipped over on resync.
  ;; The plan was originally to use (named) portals with Execute limit
  ;; and rely on PortalSuspended to implement staging of input.
  ;; Unfortunately, the server (tested with 10.1) doesn't start
  ;; sending anything back until it sees a Sync; this kills
  ;; the portal unless it's in a BEGIN/COMMIT block so the backpressure
  ;; idea using portal suspension can't work without wrapping every
  ;; query in an explicit txn (which is undesirable for obvious reasons)
  (def (query-start name params)
    ;; Bind ("" name params) ->  BindComplete | ErrorResponse
    (maybe-sync!)
    (send! ['Bind "" name . params])
    (send! '(Execute "" 0))
    (send! '(Sync))
    (match (recv!)
      (['BindComplete]
       (let ((ch (make-channel query-limit))
             (token (make-!token)))
         (set! query-output ch)
         (set! query-token token)
         (values ch token)))
      (['ErrorResponse msg . irritants]
       (resync!)
       (apply raise-sql-error 'postgresql-query! msg irritants))))

  (def (query-pump)
    ;; Execute ("")          -> DataRow ...
    ;;                          CommandComplete | EmptyQueryResponse
    ;;                          | ErrorResponse | PortalSuspended.
    ;; Sync                  -> ReadyForQuery
    (let/cc break
      (let lp ()
        (match (recv!)
          (['DataRow . cols]
           (cond
            ((channel-try-put query-output cols)
             (lp))
            (else
             (channel-sync query-output cols query-token)
             (break))))
          (['CommandComplete tag]
           (void))
          ([(or 'PortalSuspended 'EmptyQueryResponse)]
           (void))
          (['ErrorResponse msg . irritants]
           (channel-sync query-output (make-sql-error msg irritants 'postgresql-query!)))))
      (channel-close query-output)
      (set! query-output #f)
      (set! query-token #f)
      (resync!)))

  <<simple-query-start>>

  <<simple-query-pump>>

  <<continue>>
  
  (def (close name)
    ;; Close (name) -> CloseComplete | ErrorResponse
    (if query-output
      (push! name deferred-close)
      (begin
        (send! ['Close #\S name])
        (send! '(Sync))
        (match (recv!)
          (['CloseComplete]
           (void))
          (['ErrorResponse msg . irritants]
           (warnf "error closing statement ~a: ~a" name msg)))
        (resync!))))

  (def (shutdown!)
    (send! '(Sync))
    (resync!)
    (send! '(Terminate))
    (raise 'shutdown))

  (defrules do-action ()
    ((_ k action)
     (try
      (let (res action)
        (!!value res k))
      (catch (e)
        (!!error e k)
        (unless (sql-error? e)
          (raise e)))))
    ((recur k action continue ...)
     (begin
       (recur k action)
       continue ...)))

  (def (loop)
    (<- ((!postgresql.prepare name sql k)
         (do-action k (prepare name sql)))
        ((!postgresql.exec name params k)
         (do-action k (exec name params)))
        ((!postgresql.query name params k)
         (do-action k (query-start name params) (query-pump)))
        ((!postgresql.simple-query str k)
         (do-action k (simple-query-start str) (simple-query-pump)))
        ((!postgresql.continue token) (continue token))
        ((!postgresql.reset token)
          (maybe-sync!))
        ((!postgresql.close name)
         (close name))
        ((!postgresql.shutdown)
         (shutdown!))
        (bogus
         (warnf "unexpected message: ~a" bogus)))
    (loop))

  (try
   (loop)
   (catch (e)
     (unless (eq? e 'shutdown)
       (errorf "unhandled exception: ~a" e)
       (raise e)))
   (finally
    (when query-output
      (channel-sync query-output (make-sql-error "connection error" [] 'postgresql-driver))
      (channel-close query-output))
    (close-port sock))))
#+end_src
** Messages

*** Message Data Types

 - Intn(i) :: An n-bit integer in network byte order (most significant byte
   first). If i is specified it is the exact value that will appear, otherwise
   the value is variable. Eg. Int16, Int32(42).

 - Intn[k] :: An array of k n-bit integers, each in network byte order. The
   array length k is always determined by an earlier field in the message. Eg.
   Int16[M].

 - String(s) :: A null-terminated string (C-style string). There is no specific
   length limitation on strings. If s is specified it is the exact value that
   will appear, otherwise the value is variable. Eg. String, String("user").

       *Note* There is no predefined limit on the length of a string that can be
   returned by the backend. Good coding strategy for a frontend is to use an
   expandable buffer so that anything that fits in memory can be accepted. If
   that's not feasible, read the full string and discard trailing characters
   that don't fit into your fixed-size buffer.

 - Byten(c) :: Exactly n bytes. If the field width n is not a constant, it is
   always determinable from an earlier field in the message. If c is specified
   it is the exact value. Eg. Byte2, Byte1('\n').

*** Front End Messages
:PROPERTIES:
:CUSTOM_ID: frontEndMessages
:END:

#+begin_src scheme :noweb-ref "def front end messages"
(defmessage-frontend
  (Bind                     #\B  marshal-bind)
  (Close                    #\C  marshal-close)
  (CopyData                 #\d (marshal-fail 'CopyData))
  (CopyDone                 #\c (marshal-fail 'CopyDone))
  (CopyFail                 #\f (marshal-fail 'CopyFail))
  (Describe                 #\D  marshal-describe)
  (Execute                  #\E  marshal-exec)
  (Flush                    #\H  marshal-empty)
  (FunctionCall             #\F (marshal-fail 'FunctionCall))
  (GSSResponse              #\p (marshal-fail 'GSSResponse))
  (Parse                    #\P  marshal-parse)
  (PasswordMessage          #\p  marshal-passwd)
  (Query                    #\Q  marshal-query)
  (SASLInitialResponse      #\p  marshal-sasl-initial-reponse)
  (SASLResponse             #\p  marshal-sasl-response)
  (Sync                     #\S  marshal-empty)
  (Terminate                #\X  marshal-empty))
#+end_src

** The Protocol

*** Protocols
     :PROPERTIES:
     :CUSTOM_ID: protocols
     :END:

Beyond structured messages, Gerbil provides protocols for structured
interaction. Protocol messages can be one way messages (instances of
=!event=), a remote call (instances of =!call=) or a value for a
previous call (=!value= or =!error=).

Protocols are defined with =defproto=, which defines structures and
macros for using the protocol interfaces, together with marshalling
support.

#+BEGIN_SRC scheme
(defproto postgresql
  (prepare name sql)
  (exec name params)
  (query name params)
  (simple-query str)
  event:
  (continue token)
  (reset token)
  (close name)
  (shutdown))
#+END_SRC

In the example, we define a protocol =postgresql= with many calls. For ~exec~,
for example, The macro defines the structures and macros for using the
interface:

#+BEGIN_SRC scheme
  (defstruct postgresql.exec (name params))
  (defsyntax-for-match !postgresql.exec ...)
  (defrules !!postgresql.exec ...
#+END_SRC

The invocation =(!!postgresql.exec postgresql name params)= constructs a =!call=
protocol message with an instance of =postgresql.exec= and a gensymed
continuation id. It then sends the message to the =postgresql= actor and waits
for a =!value= or =!error= message matching the continuation. If it receives a
=!value= it returns it, and if it receives an =!error= it signals an error.

In the actor, the =(!postgresql.exec what p k)= matches a =!call= with the value
matching =(postgresql.exec what p)= and the continuation token bound to =k=. The
actor displays its message, and then responds by sending a value with the
=!!value= macro. An error could be signalled with the =!!error= macro.

The syntax for =!!value= and =!!error= is similar: the take an optional
destination (which defaults to =@source=), a value or error message and
the continuation token:

#+BEGIN_SRC scheme
  (!!value [@source] val token)
  (!!error [@source] msg token)
#+END_SRC

*** Protocol I/O

**** ~postgresql-send!~
:PROPERTIES:
:CUSTOM_ID: postgresqlSend
:END:

#+begin_src scheme :noweb-ref postgresql-send!
(def (postgresql-send! sock msg)
  (def (marshal-and-write tid body marshal)
    (let* ((payload (marshal body))
           (payload-len
            (cond
             ((u8vector? payload)
              (u8vector-length payload))
             ((chunked-output-buffer? payload)
              (chunked-output-length payload))
             (else
              (raise-io-error 'postgresql-send! "unexpected payload" tid body payload)))))
      (when tid
        (write-u8 tid sock))
      (write-u32 (##fx+ payload-len 4) sock)
      (if (u8vector? payload)
        (let (len (u8vector-length payload))
          (when (##fx> len 0)
            (write-subu8vector payload 0 len sock)))
        (for-each
          (lambda (u8v)
            (write-subu8vector u8v 0 (u8vector-length u8v) sock))
          (chunked-output-chunks payload)))
      (force-output sock)))

  (def (write-u32 u32 sock)
    (write-u8 (##fxand (##fxarithmetic-shift-right u32 24) #xff) sock)
    (write-u8 (##fxand (##fxarithmetic-shift-right u32 16) #xff) sock)
    (write-u8 (##fxand (##fxarithmetic-shift-right u32 8) #xff) sock)
    (write-u8 (##fxand u32 #xff) sock))

  (DEBUG "SEND " msg)
  (with ([tag . body] msg)
    (cond
     ((hash-get +frontend-messages+ tag)
      => (match <>
           ([tid . marshal]
            (marshal-and-write tid body marshal))))
     ((eq? tag 'StartupMessage)
      (marshal-and-write #f body marshal-startup))
     (else
      (raise-io-error 'postgresql-send! "cannot marshal; unknown message tag" msg)))))
#+end_src
* /File/ ~postgresql.ss~

#+begin_src scheme :tangle postgresql.ss :noweb yes
;;; -*- Gerbil -*-
;;; (C) drewc, vyzo
;;; PostgreSQL dbi interface

(import :drewc/db/dbi
        :drewc/db/postgresql-driver
        :std/iter
        :std/misc/channel
        :std/srfi/19)
(export postgresql-connect
        (struct-out postgresql-command
                    postgresql-statement
                    postgresql-query)
        defcatalog
        defcatalog-default
        default-catalog
        current-catalog)

<<postgresql-connection>>

<<command struct>>

<<command reset>>

<<statement struct>>

<<statement query>>

<<Prepared Statement Methods>>

<<query struct>>

<<query query>>

<<catalog>>


#+end_src

* /File/ ~postgresql-driver.ss~

#+begin_src scheme :tangle postgresql-driver.ss :noweb yes
;;; -*- Gerbil -*-
;;; (C) vyzo
;;; PostgreSQL driver

(import :gerbil/gambit/threads
        :gerbil/gambit/ports
        :gerbil/gambit/bits
        :std/actor/proto
        :std/actor/message
        :std/misc/channel
        :std/misc/list
        :std/net/bio
        :std/net/sasl
        :std/text/utf8
        :std/text/hex
        :std/crypto
        :std/logger
        :std/sugar
        :std/error
        :drewc/db/dbi)
(export postgresql-connect!
        postgresql-prepare-statement!
        postgresql-close-statement!
        postgresql-exec!
        postgresql-query!
        postgresql-simple-query!
        postgresql-continue!
        postgresql-reset!
        postgresql-close!
        postgresql-socket
        postgresql-message
        postgresql-message-name
        postgresql-message-args
        postgresql-RowDescription?
        postgresql-CommandComplete?
        (rename: !token? query-token?))

(deflogger postgres)

;;; driver interface
(defproto postgresql
  (prepare name sql)
  (exec name params)
  (query name params)
  (simple-query str)
  event:
  (continue token)
  (reset token)
  (close name)
  (shutdown))

<<postgresql-message>>

(defrules with-driver ()
  ((_ conn driver body ...)
   (cond
    ((thread? conn)
     (let (driver conn)
       body ...))
    ((connection-e conn)
     => (lambda (driver) body ...))
    (else
     (error "connection has been closed" conn)))))

(defrules get-driver ()
  ((_ conn)
   (if (thread? conn) conn (connection-e conn))))

<<postgresql-socket>>

#;(defrules DEBUG ()
  ((_ what arg ...)
   (begin
     (display what)
     (begin (write arg) (display " ")) ...
     (newline))))

(defrules DEBUG ()
  ((_ what arg ...)
   (void)))

(def (postgresql-prepare-statement! conn name sql)
  (with-driver conn driver
    (!!postgresql.prepare driver name sql)))

(def (postgresql-close-statement! conn name)
  (alet (driver (get-driver conn))
    (!!postgresql.close driver name)))

(def (postgresql-exec! conn name bind)
  (with-driver conn driver
    (!!postgresql.exec driver name bind)))

(def (postgresql-query! conn name bind)
  (with-driver conn driver
    (!!postgresql.query driver name bind)))

<<postgresql-simple-query>>

(def (postgresql-continue! conn token)
  (if (!token? token)
    (with-driver conn driver
      (!!postgresql.continue driver token))
    (error "Bad argument; illegal query token" token)))

(def (postgresql-reset! conn token)
  (if (!token? token)
    (alet (driver (get-driver conn))
      (!!postgresql.reset driver token))
    (error "Bad argument; illegal query token" token)))

(def (postgresql-close! conn)
  (alet (driver (get-driver conn))
    (!!postgresql.shutdown driver)))

;;; driver implementation
<<postgresql-connect!>>

<<postgresql-driver>>

;;; Protocol I/O
<<postgresql-send!>>

(def (postgresql-recv! sock buf)
  (def (read-u32 sock u8v)
    (let (rd (read-subu8vector u8v 0 4 sock))
      (cond
       ((##fx< rd 4)
        (raise-io-error 'postgresql-recv! "premature end of input" rd))
       ((##fxarithmetic-shift-left? (##u8vector-ref u8v 0) 24)
        => (lambda (bits)
             (##fxior bits
                      (##fxarithmetic-shift-left (##u8vector-ref u8v 1) 16)
                      (##fxarithmetic-shift-left (##u8vector-ref u8v 2) 8)
                      (##u8vector-ref u8v 3))))
       (else
        (bitwise-ior (arithmetic-shift (##u8vector-ref u8v 0) 24)
                     (##fxarithmetic-shift-left (##u8vector-ref u8v 1) 16)
                     (##fxarithmetic-shift-left (##u8vector-ref u8v 2) 8)
                     (##u8vector-ref u8v 3))))))

  (DEBUG "RECEIVE!")
  (let* ((tid (read-u8 sock))
         (_ (when (eof-object? tid)
              (raise-io-error 'postgresql-recv! "connection closed")))
         (payload-len (read-u32 sock (unbox buf)))
         (payload-len (##fx- payload-len 4))
         (u8buf
          (let (u8buf (unbox buf))
            (if (##fx< (u8vector-length u8buf) payload-len)
              (let (u8buf (make-u8vector payload-len))
                (set! (box buf) u8buf)
                u8buf)
              u8buf)))
         (rd
          (if (##fx> payload-len 0)
            (read-subu8vector u8buf 0 payload-len sock)
            0))
         (_ (when (##fx< rd payload-len)
              (raise-io-error 'postgresql-recv! "premature end of input" rd tid payload-len)))
         (bio (open-input-buffer u8buf 0 payload-len)))

    (DEBUG "READ MESSAGE " tid payload-len)
    (cond
     ((vector-ref +backend-messages+ tid)
      => (match <>
           ([tag . unmarshal]
            (DEBUG "UNMARSHAL " tag)
            (let* ((body (unmarshal bio))
                   (msg (cons tag body)))
              (DEBUG "RECEIVE " msg)
              msg))))
     (else
      (raise-io-error 'postgresql-recv! "unexpected backend message" tid)))))

;;; message unmarshaling
(def (unmarshal-ignore bio)
  '(...))

(def (unmarshal-empty bio)
  '())

(def (unmarshal-authen-request bio)
  (let (t (bio-read-u32 bio))
    (case t
      ((0) '(AuthenticationOk))
      ((2) '(AuthenticationKerberosV5))
      ((3) '(AuthenticationCleartextPassword))
      ((5)
       (let (salt (make-u8vector 4))
         (bio-read-bytes salt bio)
         ['AuthenticationMD5Password salt]))
      ((6) '(AuthenticationSCMCredential))
      ((7) '(AuthenticationGSS))
      ((8)
       (let (data (unmarshal-bytes-rest bio))
         ['AuthenticationGSSContinue data]))
      ((9) '(AuthenticationSSPI))
      ((10)
       (let (mechanisms (unmarshal-string-list bio))
         ['AuthenticationSASL . mechanisms]))
      ((11)
       (let (data (unmarshal-string-rest bio))
         ['AuthenticationSASLContinue data]))
      ((12)
       (let (data (unmarshal-string-rest bio))
         ['AuthenticationSASLFinal data]))
      (else
       [t '...]))))

(def (unmarshal-string-list bio)
  (let lp ((r []))
    (let (next (unmarshal-string bio))
      (if (string-empty? next)
        (reverse r)
        (lp (cons next r))))))

(def (unmarshal-string bio)
  (let lp ((bytes []))
    (let (next (bio-read-u8 bio))
      (if (##fx= next 0)
        (utf8->string (list->u8vector (reverse bytes)))
        (lp (cons next bytes))))))

(def (unmarshal-bytes-rest bio)
  (let* ((count (bio-input-count bio))
         (data (make-u8vector count)))
    (bio-read-bytes data bio)
    data))

(def (unmarshal-string-rest bio)
  (let (count (bio-input-count bio))
    (bio-input-utf8-decode count bio)))

(def (unmarshal-complete bio)
  (let (tag (unmarshal-string bio))
    [tag]))

(def (unmarshal-data-row bio)
  (let (count (bio-read-u16 bio))
    (let lp ((i 0) (r []))
      (if (##fx< i count)
        (let (len (bio-read-s32 bio))
          (if (##fx>= len 0)
            (let (str (bio-input-utf8-decode len bio))
              (lp (##fx+ i 1) (cons str r)))
            (lp (##fx+ i 1) (cons #f r)))) ; NULL
        (reverse r)))))

(def (unmarshal-error-notice bio)
  (let lp ((r []))
    (let (t (bio-read-u8 bio))
      (if (##fx= t 0)
        (let* ((alist (reverse r))
               (msg (assgetq #\M alist)))
          (cons msg alist))
        (let (field (unmarshal-string bio))
          (lp (cons (cons (integer->char t) field) r)))))))

(def (unmarshal-param-description bio)
  (let (count (bio-read-u16 bio))
    (let lp ((i 0) (r []))
      (if (##fx< i count)
        (let (oid (bio-read-u32 bio))
          (lp (##fx+ i 1) (cons oid r)))
        (reverse r)))))

(def (unmarshal-row-description bio)
  (let (count (bio-read-u16 bio))
    (let lp ((i 0) (r []))
      (if (##fx< i count)
        (let* ((field-name (unmarshal-string bio))
               (table-id (bio-read-u32 bio))
               (attr-id (bio-read-u16 bio))
               (type-id (bio-read-u32 bio))
               (type-sz (bio-read-s16 bio))
               (modifier (bio-read-s32 bio))
               (fmt (bio-read-u16 bio)))
          (lp (##fx+ i 1)
              (cons [field-name table-id attr-id type-id type-sz modifier fmt] r)))
        (reverse r)))))

(def (unmarshal-ready bio)
  (let (status (bio-read-u8 bio))
    [(integer->char status)]))

;;; message marshaling
(def (marshal-fail what)
  (lambda (body)
    (raise-io-error 'postgresql-send! "Cannot marshal; unsupported message" (cons what body))))

(def (marshal-empty body)
  '#u8())

(def (marshal-string str bio)
  (bio-write-string str bio)
  (bio-write-u8 0 bio))

(def (marshal-startup body)
  (with ([[param . value] ...] body)
    (let (bio (open-serializer-output-buffer))
      (bio-write-u32 196608 bio) ; Protocol v3.0
      (for-each
        (lambda (param value)
          (marshal-string param bio)
          (marshal-string value bio))
        param value)
      (bio-write-u8 0 bio))))

(def (marshal-bind body)
  (with ([portal-name stmt-name . params] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string portal-name bio)
      (marshal-string stmt-name bio)
      (bio-write-u16 0 bio)
      (bio-write-u16 (length params) bio)
      (for-each
        (lambda (param)
          (cond
           ((not param)
            (bio-write-s32 -1 bio))
           ((string? param)
            (let (len (string-utf8-length param))
              (bio-write-u32 len bio)
              (bio-write-string param bio)))
           ((u8vector? param)
            (bio-write-u32 (u8vector-length param) bio)
            (bio-write-bytes param bio))
           (else
            (raise-io-error 'postgresql-send! "Cannot marshal; bad parameter" param))))
        params)
      (bio-write-u16 0 bio)
      bio)))

(def (marshal-close body)
  (marshal-describe body))

(def (marshal-describe body)
  (with ([what name] body)
    (let (bio (open-serializer-output-buffer))
      (bio-write-u8 (char->integer what) bio)
      (marshal-string name bio)
      bio)))

(def (marshal-exec body)
  (with ([portal limit] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string portal bio)
      (bio-write-u32 0 bio)
      bio)))

(def (marshal-parse body)
  (with ([stmt sql] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string stmt bio)
      (marshal-string sql bio)
      (bio-write-u16 0 bio)
      bio)))

(def (marshal-passwd body)
  (with ([passwd] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string passwd bio)
      bio)))

(def (marshal-query body)
  (with ([sql] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string sql bio)
      bio)))

(def (marshal-sasl-initial-reponse body)
  (with ([mechanism data] body)
    (let (bio (open-serializer-output-buffer))
      (marshal-string mechanism bio)
      (if data
        (let (len (string-utf8-length data))
          (bio-write-u32 len bio)
          (bio-write-string data bio))
        (bio-write-s32 -1 bio))
      bio)))

(def (marshal-sasl-response body)
  (with ([data] body)
    (string->utf8 data)))

;;; dispatch tables
(def +backend-messages+
  (make-vector 256 #f))
(def +frontend-messages+
  (make-hash-table-eq))

(defrules defmessage-backend ()
  ((_ (id char unmarshal) ...)
   (begin
     (let (t (char->integer char))
       (vector-set! +backend-messages+ t (cons 'id unmarshal)))
     ...)))

(defrules defmessage-frontend ()
  ((_ (id char marshal) ...)
   (begin
     (let (t (char->integer char))
       (hash-put! +frontend-messages+ 'id (cons t marshal)))
     ...)))

(defmessage-backend
  (AuthenticationRequest    #\R unmarshal-authen-request)
  (BackendKeyData           #\K unmarshal-ignore)
  (BindComplete             #\2 unmarshal-empty)
  (CloseComplete            #\3 unmarshal-empty)
  (CommandComplete          #\C unmarshal-complete)
  (CopyData                 #\d unmarshal-ignore)
  (CopyDone                 #\c unmarshal-ignore)
  (CopyInResponse           #\G unmarshal-ignore)
  (CopyOutResponse          #\H unmarshal-ignore)
  (CopyBothResponse         #\W unmarshal-ignore)
  (DataRow                  #\D unmarshal-data-row)
  (EmptyQueryResponse       #\I unmarshal-empty)
  (ErrorResponse            #\E unmarshal-error-notice)
  (FunctionCallResponse     #\V unmarshal-ignore)
  (NegotiateProtocolVersion #\v unmarshal-ignore)
  (NoData                   #\n unmarshal-empty)
  (NoticeResponse           #\N unmarshal-error-notice)
  (NotificationResponse     #\A unmarshal-ignore)
  (ParameterDescription     #\t unmarshal-param-description)
  (ParameterStatus          #\S unmarshal-ignore)
  (ParseComplete            #\1 unmarshal-empty)
  (PortalSuspended          #\s unmarshal-empty)
  (ReadyForQuery            #\Z unmarshal-ready)
  (RowDescription           #\T unmarshal-row-description))

(defmessage-frontend
  (Bind                     #\B  marshal-bind)
  (Close                    #\C  marshal-close)
  (CopyData                 #\d (marshal-fail 'CopyData))
  (CopyDone                 #\c (marshal-fail 'CopyDone))
  (CopyFail                 #\f (marshal-fail 'CopyFail))
  (Describe                 #\D  marshal-describe)
  (Execute                  #\E  marshal-exec)
  (Flush                    #\H  marshal-empty)
  (FunctionCall             #\F (marshal-fail 'FunctionCall))
  (GSSResponse              #\p (marshal-fail 'GSSResponse))
  (Parse                    #\P  marshal-parse)
  (PasswordMessage          #\p  marshal-passwd)
  (Query                    #\Q  marshal-query)
  (SASLInitialResponse      #\p  marshal-sasl-initial-reponse)
  (SASLResponse             #\p  marshal-sasl-response)
  (Sync                     #\S  marshal-empty)
  (Terminate                #\X  marshal-empty))

#+end_src
